<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:p="urn:schemas-microsoft-com:office:powerpoint" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head>
  
  <title>CMSIS: Cortex Microcontroller Software Interface Standard</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta name="ProgId" content="FrontPage.Editor.Document">
  <style>
<!--
/*-----------------------------------------------------------Keil Software CHM Style Sheet
-----------------------------------------------------------*/
body { color: #000000; background-color: #FFFFFF; font-size: 75%; font-family: Verdana, Arial, 'Sans Serif' }
a:link { color: #0000FF; text-decoration: underline }
a:visited { color: #0000FF; text-decoration: underline }
a:active { color: #FF0000; text-decoration: underline }
a:hover { color: #FF0000; text-decoration: underline }
h1 { font-family: Verdana; font-size: 18pt; color: #000080; font-weight: bold; text-align: Center; margin-right: 3 }
h2 { font-family: Verdana; font-size: 14pt; color: #000080; font-weight: bold; background-color: #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
h3 { font-family: Verdana; font-size: 10pt; font-weight: bold; background-color: #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
pre { font-family: Courier New; font-size: 10pt; background-color: #CCFFCC; margin-left: 24; margin-right: 24 }
ul { list-style-type: square; margin-top: 6pt; margin-bottom: 0 }
ol { margin-top: 6pt; margin-bottom: 0 }
li { clear: both; margin-bottom: 6pt }
table { font-size: 100%; border-width: 0; padding: 0 }
th { color: #FFFFFF; background-color: #000080; text-align: left; vertical-align: bottom; padding-right: 6pt }
tr { text-align: left; vertical-align: top }
td { text-align: left; vertical-align: top; padding-right: 6pt }
.ToolT { font-size: 8pt; color: #808080 }
.TinyT { font-size: 8pt; text-align: Center }
code { color: #000000; background-color: #E0E0E0; font-family: 'Courier New', Courier; line-height: 120%; font-style: normal }
/*-----------------------------------------------------------Notes
-----------------------------------------------------------*/
p.note { font-weight: bold; clear: both; margin-bottom: 3pt; padding-top: 6pt }
/*-----------------------------------------------------------Expanding/Contracting Divisions
-----------------------------------------------------------*/
#expand { text-decoration: none; margin-bottom: 3pt }
img.expand { border-style: none; border-width: medium }
div.expand { display: none; margin-left: 9pt; margin-top: 0 }
/*-----------------------------------------------------------Where List Tags
-----------------------------------------------------------*/
p.wh { font-weight: bold; clear: both; margin-top: 6pt; margin-bottom: 3pt }
table.wh { width: 100% }
td.whItem { white-space: nowrap; font-style: italic; padding-right: 6pt; padding-bottom: 6pt }
td.whDesc { padding-bottom: 6pt }
/*-----------------------------------------------------------Keil Table Tags
-----------------------------------------------------------*/
table.kt { width: 100%; border: 1pt solid #000000 }
th.kt { white-space: nowrap; border-bottom: 1pt solid #000000; padding-left: 6pt; padding-right: 6pt; padding-top: 4pt; padding-bottom: 4pt }
tr.kt { }
td.kt { color: #000000; background-color: #E0E0E0; border-top: 1pt solid #A0A0A0; padding-left: 6pt; padding-right: 6pt; padding-top: 2pt; padding-bottom: 2pt }
/*----------------------------------------------------------------------------------------------------------------------*/
    .style1 {
	background-color: #E0E0E0;
}
.O
	{color:#1D315B;
	font-size:149%;}
    -->
  </style></head>
<body>
<h1>Cortex Microcontroller Software Interface Standard</h1>

<p align="center">This file describes the Cortex Microcontroller Software Interface Standard (CMSIS).</p>
<p align="center">Version: 2.10 - July 2011</p>

<p class="TinyT">Information in this file, the accompany manuals, and software is<br>
                 Copyright © ARM Ltd.<br>All rights reserved.
</p>

<hr>

<p><span style="FONT-WEIGHT: bold">Revision History</span></p>
<ul>
	<li>Version 1.00: initial release. </li>
	<li>Version 1.01: added __LDREX<em>x</em>, __STREX<em>x</em>, and __CLREX.</li>
	<li>Version 1.02: added Cortex-M0. </li>
	<li>Version 1.10: second review. </li>
	<li>Version 1.20: third review. </li>
	<li>Version 1.30 PRE-RELEASE: reworked Startup Concept, additional Debug Functionality.</li>
	<li>Version 1.30 2nd PRE-RELEASE: changed folder structure, added doxyGen comments, added Bit definitions.</li>
	<li>Version 1.30: updated Device Support Packages.</li>
	<li>Version 2.00: added Cortex-M4 support.</li>
	<li>Version 2.01: internal review.</li>
	<li>Version 2.02: updated Device Specific Defines</li>
	<li>Version 2.10: reworked core include files</li>
</ul>

<hr>

<h2>Contents</h2>

<ol>
  <li class="LI2"><a href="#1">About</a></li>
  <li class="LI2"><a href="#2">Coding Rules and Conventions</a></li>
  <li class="LI2"><a href="#3">CMSIS Files</a></li>
  <li class="LI2"><a href="#4">Core Peripheral Access Layer</a></li>
  <li class="LI2"><a href="#5">CMSIS Example</a></li>
  <li class="LI2"><a href="#6">CMSIS MISRA-C:2004 Compliance Exceptions</a></li>
</ol>

<h2><a name="1"></a>About</h2>

<p>
  The <strong>Cortex Microcontroller Software Interface Standard (CMSIS)</strong> answers the challenges
  that are faced when software components are deployed to physical microcontroller devices based on a
  Cortex-M0 or Cortex-M3 processor. The CMSIS will be also expanded to future Cortex-M 
  processor cores (the term Cortex-M is used to indicate that). The CMSIS is defined in close co-operation
  with various silicon and software vendors and provides a common approach to interface to peripherals, 
  real-time operating systems, and middleware components.
</p>

<p>ARM provides as part of the CMSIS the following software layers that are
available for various compiler implementations:</p>
<ul>
  <li><strong>Core Peripheral Access Layer</strong>: contains name definitions, 
    address definitions and helper functions to
    access core registers and peripherals. It defines also a device
    independent interface for RTOS Kernels that includes debug channel
    definitions.</li>
</ul>

<p>These software layers are expanded by Silicon partners with:</p>
<ul>
  <li><strong>Device Peripheral Access Layer</strong>: provides definitions
    for all device peripherals</li>
  <li><strong>Access Functions for Peripherals (optional)</strong>: provides
    additional helper functions for peripherals</li>
</ul>

<p>CMSIS defines for a Cortex-M Microcontroller System:</p>
<ul>
  <li style="text-align: left;">A common way to access peripheral registers
    and a common way to define exception vectors.</li>
  <li style="text-align: left;">The register names of the <strong>Core
    Peripherals</strong> and<strong> </strong>the names of the <strong>Core
    Exception Vectors</strong>.</li>
  <li>An device independent interface for RTOS Kernels including a debug
    channel.</li>
</ul>

<p>
  By using CMSIS compliant software components, the user can easier re-use template code. 
  CMSIS is intended to enable the combination of software components from multiple middleware vendors.
</p>

<h2><a name="2"></a>Coding Rules and Conventions</h2>

<p>
  The following section describes the coding rules and conventions used in the CMSIS 
  implementation. It contains also information about data types and version number information.
</p>

<h3>Essentials</h3>
<ul>
  <li>The CMSIS C code conforms to MISRA 2004 rules. In case of MISRA violations, 
      there are disable and enable sequences for PC-LINT inserted.</li>
  <li>ANSI standard data types defined in the ANSI C header file
    <strong>&lt;stdint.h&gt;</strong> are used.</li>
  <li>#define constants that include expressions must be enclosed by
    parenthesis.</li>
  <li>Variables and parameters have a complete data type.</li>
  <li>All functions in the <strong>Core Peripheral Access Layer</strong> are
    re-entrant.</li>
  <li>The <strong>Core Peripheral Access Layer</strong> has no blocking code
    (which means that wait/query loops are done at other software layers).</li>
  <li>For each exception/interrupt there is definition for:
  <ul>
    <li>an exception/interrupt handler with the postfix <strong>_Handler </strong>
	(for exceptions) or <strong>_IRQHandler</strong> (for interrupts).</li>
    <li>a default exception/interrupt handler (weak definition) that contains an endless loop.</li>
    <li>a #define of the interrupt number with the postfix <strong>_IRQn</strong>.</li>
  </ul></li>
</ul>

<h3>Recommendations</h3>

<p>The CMSIS recommends the following conventions for identifiers.</p>
<ul>
  <li><strong>CAPITAL</strong> names to identify Core Registers, Peripheral Registers, and CPU Instructions.</li>
  <li><strong>CamelCase</strong> names to identify peripherals access functions and interrupts.</li>
  <li><strong>PERIPHERAL_</strong> prefix to identify functions that belong to specify peripherals.</li>
  <li><strong>Doxygen</strong> comments for all functions are included as described under <strong>Function Comments</strong> below.</li>
</ul>

<b>Comments</b>

<ul>
  <li>Comments use the ANSI C90 style (<em>/* comment */</em>) or C++ style 
  (<em>// comment</em>). It is assumed that the programming tools support today 
	consistently the C++ comment style.</li>
  <li><strong>Function Comments</strong> provide for each function the following information:
  <ul>
    <li>one-line brief function overview.</li>
    <li>detailed parameter explanation.</li>
    <li>detailed information about return values.</li>
    <li>detailed description of the actual function.</li>
  </ul>
  <p><b>Doxygen Example:</b></p>
  <pre>
/** 
 * @brief  Enable Interrupt in NVIC Interrupt Controller
 * @param  IRQn  interrupt number that specifies the interrupt
 * @return none.
 * Enable the specified interrupt in the NVIC Interrupt Controller.
 * Other settings of the interrupt such as priority are not affected.
 */</pre>
  </li>
</ul>

<h3>Data Types and IO Type Qualifiers</h3>

<p>
  The <strong>Cortex-M HAL</strong> uses the standard types from the standard ANSI C header file
  <strong>&lt;stdint.h&gt;</strong>. <strong>IO Type Qualifiers</strong> are used to specify the access
  to peripheral variables. IO Type Qualifiers are indented to be used for automatic generation of 
  debug information of peripheral registers.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">IO Type Qualifier</th>
      <th class="kt">#define</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__I</td>
      <td class="kt">volatile const</td>
      <td class="kt">Read access only</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__O</td>
      <td class="kt">volatile</td>
      <td class="kt">Write access only</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__IO</td>
      <td class="kt">volatile</td>
      <td class="kt">Read and write access</td>
    </tr>
  </tbody>
</table>

<h3>CMSIS Version Number</h3>
<p>
  File <strong>core_cm4.h</strong> contains the version number of the CMSIS with the following define:
</p>

<pre>
#define __CM4_CMSIS_VERSION_MAIN  (0x02)      /* [31:16] main version       */
#define __CM4_CMSIS_VERSION_SUB   (0x10)      /* [15:0]  sub version        */
#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM4_CMSIS_VERSION_SUB)</pre>

<p>
  File <strong>core_cm3.h</strong> contains the version number of the CMSIS with the following define:
</p>

<pre>
#define __CM3_CMSIS_VERSION_MAIN  (0x02)      /* [31:16] main version       */
#define __CM3_CMSIS_VERSION_SUB   (0x10)      /* [15:0]  sub version        */
#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM3_CMSIS_VERSION_SUB)</pre>

<p>
  File <strong>core_cm0.h</strong> contains the version number of the CMSIS with the following define:
</p>

<pre>
#define __CM0_CMSIS_VERSION_MAIN  (0x02)      /* [31:16] main version       */
#define __CM0_CMSIS_VERSION_SUB   (0x10)      /* [15:0]  sub version        */
#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM0_CMSIS_VERSION_SUB)</pre>


<h3>CMSIS Cortex Core</h3>
<p>
  File <strong>core_cm4.h</strong> contains the type of the CMSIS Cortex-M with the following define:
</p>

<pre>
#define __CORTEX_M                (0x04)</pre>

<p>
  File <strong>core_cm3.h</strong> contains the type of the CMSIS Cortex-M with the following define:
</p>

<pre>
#define __CORTEX_M                (0x03)</pre>

<p>
  File <strong>core_cm0.h</strong> contains the type of the CMSIS Cortex-M with the following define:
</p>

<pre>
#define __CORTEX_M                (0x00)</pre>


<h2><a name="3"></a>CMSIS Files</h2>
<p>
  This section describes the Files provided in context with the CMSIS to access the Cortex-M
  hardware and peripherals.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">File</th>
      <th class="kt">Provider</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap"><i>device.h</i></td>
      <td class="kt">Device specific (provided by silicon partner)</td>
      <td class="kt">Defines the peripherals for the actual device. The file may use 
        several other include files to define the peripherals of the actual device.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cm0.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the core peripherals for the Cortex-M0 CPU and core peripherals.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cm3.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the core peripherals for the Cortex-M3 CPU and core peripherals.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cm4.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the core peripherals for the Cortex-M4 CPU and core peripherals.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cm4_simd.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the Cortex-M4 Core SIMD functions.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cmFunc.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the Cortex-M Core Register access functions.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">core_cmInstr.h</td>
      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
      <td class="kt">Defines the Cortex-M Core instructions.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">startup<i>_device</i></td>
      <td class="kt">ARM (adapted by compiler partner / silicon partner)</td>
      <td class="kt">Provides the Cortex-M startup code and the complete (device specific) Interrupt Vector Table</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">system<i>_device</i></td>
      <td class="kt">ARM (adapted by silicon partner)</td>
      <td class="kt">Provides a device specific configuration file for the device. It configures the device initializes 
        typically the oscillator (PLL) that is part of the microcontroller device</td>
    </tr>
  </tbody>
</table>

<h3><em>device.h</em></h3>

<p>
  The file <em><strong>device.h</strong></em> is provided by the silicon vendor and is the 
  <u><strong>central include file</strong></u> that the application programmer is using in 
  the C source code. This file contains:
</p>
<ul>
  <li>
	<p><strong>Interrupt Number Definition</strong>: provides interrupt numbers 
	(IRQn) for all core and device specific exceptions and interrupts.</p>
	</li>
	<li>
	<p><strong>Configuration for core_cm0.h / core_cm3.h / core_cm4.h</strong>: reflects the 
	actual configuration of the Cortex-M processor that is part of the actual 
	device. As such the file <strong>core_cm0.h / core_cm3.h / core_cm4.h</strong> is included that 
	implements access to processor registers and core peripherals. </p>
	</li>
	<li>
	<p><strong>Device Peripheral Access Layer</strong>: provides definitions
    for all device peripherals. It contains all data structures and the address 
	mapping for the device specific peripherals. </p>
	</li>
  <li><strong>Access Functions for Peripherals (optional)</strong>: provides
    additional helper functions for peripherals that are useful for programming 
	of these peripherals. Access Functions may be provided as inline functions 
	or can be extern references to a device specific library provided by the 
	silicon vendor.</li>
</ul>


<h4>Interrupt Number Definition</h4>

<p>To access the device specific interrupts the device.h file defines IRQn 
numbers for the complete device using a enum typedef as shown below:</p>
<pre>
typedef enum IRQn
{
/******  Cortex-M3 Processor Exceptions/Interrupt Numbers ************************************************/
  NonMaskableInt_IRQn             = -14,      /*!&lt; 2 Non Maskable Interrupt                              */
  HardFault_IRQn                  = -13,      /*!&lt; 3 Cortex-M3 Hard Fault Interrupt                      */
  MemoryManagement_IRQn           = -12,      /*!&lt; 4 Cortex-M3 Memory Management Interrupt               */
  BusFault_IRQn                   = -11,      /*!&lt; 5 Cortex-M3 Bus Fault Interrupt                       */
  UsageFault_IRQn                 = -10,      /*!&lt; 6 Cortex-M3 Usage Fault Interrupt                     */
  SVCall_IRQn                     = -5,       /*!&lt; 11 Cortex-M3 SV Call Interrupt                        */
  DebugMonitor_IRQn               = -4,       /*!&lt; 12 Cortex-M3 Debug Monitor Interrupt                  */
  PendSV_IRQn                     = -2,       /*!&lt; 14 Cortex-M3 Pend SV Interrupt                        */
  SysTick_IRQn                    = -1,       /*!&lt; 15 Cortex-M3 System Tick Interrupt                    */
/******  STM32 specific Interrupt Numbers ****************************************************************/
  WWDG_STM_IRQn                   = 0,        /*!&lt; Window WatchDog Interrupt                             */
  PVD_STM_IRQn                    = 1,        /*!&lt; PVD through EXTI Line detection Interrupt             */
  :
  :
  } IRQn_Type;</pre>


<h4>Device Specific Defines</h4>
<p>
  The following device implementation specific defines are set in the device header file and are 
  used for the Cortex-M core configuration options. Some configuration options are reflected 
  in the CMSIS layer using the #define settings described below.
</p>
<p>
  Several features in <strong>core_cm#.h</strong> are configured by the following defines 
  that must be defined before <strong>#include &lt;core_cm#.h&gt;</strong>
  preprocessor command.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">#define</th>
      <th class="kt" nowrap="nowrap">Core</th>
      <th class="kt" nowrap="nowrap">Value</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__CM0_REV</td>
      <td class="kt" nowrap="nowrap">M0</td>
      <td class="kt" nowrap="nowrap">0x0000</td>
      <td class="kt">Core revision number ([15:8] revision number, [7:0] patch number)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__CM3_REV</td>
      <td class="kt" nowrap="nowrap">M3</td>
      <td class="kt" nowrap="nowrap">0x0101 | 0x0200</td>
      <td class="kt">Core revision number ([15:8] revision number, [7:0] patch number)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__CM4_REV</td>
      <td class="kt" nowrap="nowrap">M4</td>
      <td class="kt" nowrap="nowrap">0x0000</td>
      <td class="kt">Core revision number ([15:8] revision number, [7:0] patch number)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__NVIC_PRIO_BITS</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">2 .. 8</td>
      <td class="kt">Number of priority bits implemented in the NVIC (device specific)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__MPU_PRESENT</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">0 | 1</td>
      <td class="kt">Defines if a MPU is present or not</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__FPU_PRESENT</td>
      <td class="kt" nowrap="nowrap">M4</td>
      <td class="kt" nowrap="nowrap">0 | 1</td>
      <td class="kt">Defines if a FPU is present or not</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">__Vendor_SysTickConfig</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">0 | 1</td>
      <td class="kt">When this define is setup to 1, the <strong>SysTickConfig</strong> function 
		in <strong>core_cm3.h</strong> is excluded. In this case the <em><strong>device.h</strong></em> 
		file must contain a vendor specific implementation of this function.</td>
    </tr>
  </tbody>
</table>


<h4>Device Peripheral Access Layer</h4>
<p>
  Each peripheral uses a prefix which consists of <strong>&lt;device abbreviation&gt;_</strong> 
  and <strong>&lt;peripheral name&gt;_</strong> to identify peripheral registers that access this 
  specific peripheral. The intention of this is to avoid name collisions caused
  due to short names. If more than one peripheral of the same type exists, 
  identifiers have a postfix (digit or letter). For example:
</p>
<ul>
	<li>&lt;device abbreviation&gt;_UART_Type: defines the generic register layout for all UART channels in a device.
      <pre>
typedef struct
{
  union {
  __I  uint8_t  RBR;                     /*!< Offset: 0x000 (R/ )  Receiver Buffer Register    */
  __O  uint8_t  THR;                     /*!< Offset: 0x000 ( /W)  Transmit Holding Register   */
  __IO uint8_t  DLL;                     /*!< Offset: 0x000 (R/W)  Divisor Latch LSB           */
       uint32_t RESERVED0;
  };
  union {
  __IO uint8_t  DLM;                     /*!< Offset: 0x004 (R/W)  Divisor Latch MSB           */
  __IO uint32_t IER;                     /*!< Offset: 0x004 (R/W)  Interrupt Enable Register   */
  };
  union {
  __I  uint32_t IIR;                     /*!< Offset: 0x008 (R/ )  Interrupt ID Register       */
  __O  uint8_t  FCR;                     /*!< Offset: 0x008 ( /W)  FIFO Control Register       */
  };
  __IO uint8_t  LCR;                     /*!< Offset: 0x00C (R/W)  Line Control Register       */
       uint8_t  RESERVED1[7];
  __I  uint8_t  LSR;                     /*!< Offset: 0x014 (R/ )  Line Status Register        */
       uint8_t  RESERVED2[7];
  __IO uint8_t  SCR;                     /*!< Offset: 0x01C (R/W)  Scratch Pad Register        */
       uint8_t  RESERVED3[3];
  __IO uint32_t ACR;                     /*!< Offset: 0x020 (R/W)  Autobaud Control Register   */
  __IO uint8_t  ICR;                     /*!< Offset: 0x024 (R/W)  IrDA Control Register       */
       uint8_t  RESERVED4[3];
  __IO uint8_t  FDR;                     /*!< Offset: 0x028 (R/W)  Fractional Divider Register */
       uint8_t  RESERVED5[7];
  __IO uint8_t  TER;                     /*!< Offset: 0x030 (R/W)  Transmit Enable Register    */
       uint8_t  RESERVED6[39];
  __I  uint8_t  FIFOLVL;                 /*!< Offset: 0x058 (R/ )  FIFO Level Register         */
} LPC_UART_TypeDef;</pre>
  </li>
	<li>&lt;device abbreviation&gt;_UART1: is a pointer to a register structure that refers to a specific UART. 
      For example UART1-&gt;THR is the transmit holding register of UART1.
      <pre>
#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )</pre>
  </li>
</ul>

<h5>Minimal Requiements</h5>
<p>
  To access the peripheral registers and related function in a device the files <strong><em>device.h</em></strong> 
  and <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong> defines as a minimum:
</p>
<ul>
  <li>The <strong>Register Layout Typedef</strong> for each peripheral that defines all register names.
      Names that start with RESERVE are used to introduce space into the structure to adjust the addresses of
      the peripheral registers. For example:
      <pre>
typedef struct
{
  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
} SysTick_Type;</pre>
  </li>

  <li>
    <strong>Base Address</strong> for each peripheral (in case of multiple peripherals 
    that use the same <strong>register layout typedef</strong> multiple base addresses are defined). For example:
    <pre>
#define SysTick_BASE (SCS_BASE + 0x0010)            /* SysTick Base Address */</pre>
  </li>

  <li>
    <strong>Access Definition</strong> for each peripheral (in case of multiple peripherals that use 
    the same <strong>register layout typedef</strong> multiple access definitions exist, i.e. LPC_UART0, 
    LPC_UART2). For Example:
    <pre>
#define SysTick ((SysTick_Type *) SysTick_BASE)     /* SysTick access definition */</pre>
  </li>
</ul>

<p>
  These definitions allow to access the peripheral registers from user code with simple assignments like:
</p>
<pre>SysTick-&gt;CTRL = 0;</pre>

<h5>Optional Features</h5>
<p>In addition the <em> <strong>device.h </strong></em>file may define:</p>
<ul>
	<li>
    #define constants that simplify access to the peripheral registers. 
	  These constant define bit-positions or other specific patterns are that required for the 
    programming of the peripheral registers. The identifiers used start with 
    <strong>&lt;device abbreviation&gt;_</strong> and <strong>&lt;peripheral name&gt;_</strong>. 
    It is recommended to use CAPITAL letters for such #define constants.
  </li>
	<li>
    Functions that perform more complex functions with the peripheral (i.e. status query before 
    a sending register is accessed). Again these function start with 
    <strong>&lt;device abbreviation&gt;_</strong> and <strong>&lt;peripheral name&gt;_</strong>. 
  </li>
</ul>

<h3>core_cm0.h</h3>
<p>
  File <b>core_cm0.h</b> describes the data structures for the Cortex-M0 core peripherals and does 
  the address mapping of this structures. It also provides basic access to the Cortex-M0 core registers 
  and core peripherals with efficient functions (defined as <strong>static inline</strong>).
</p>
<p>This file implement the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M0.</p>
<p>The define <em> <strong>__CMSIS_GENERIC</strong></em> allows to use core_cm0.h in generic 
   library projects that are device independent. Only core relevant types and defines are used.</p>

<h3>core_cm3.h</h3>
<p>
  File <b>core_cm3.h</b> describes the data structures for the Cortex-M3 core peripherals and does 
  the address mapping of this structures. It also provides basic access to the Cortex-M3 core registers 
  and core peripherals with efficient functions (defined as <strong>static inline</strong>).
</p>
<p>This file implement the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M3.</p>
<p>The define <em> <strong>__CMSIS_GENERIC</strong></em> allows to use core_cm3.h in generic 
   library projects that are device independent. Only core relevant types and defines are used.</p>

<h3>core_cm4.h, core_cm4_simd.h</h3>
<p>
  File <b>core_cm4.h</b> describes the data structures for the Cortex-M4 core peripherals and does 
  the address mapping of this structures. It also provides basic access to the Cortex-M4 core registers 
  and core peripherals with efficient functions (defined as <strong>static inline</strong>).
</p>
<p>
  File <b>core_cm4_simd.h</b> defines Cortex-M4 SIMD instructions.
</p>
<p>Together these files implement the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M4.</p>
<p>The define <em> <strong>__CMSIS_GENERIC</strong></em> allows to use core_cm4.h in generic 
   library projects that are device independent. Only core relevant types and defines are used.</p>

<h3>core_cmFunc.h and core_cmInstr.h</h3>
<p>
  File <b>core_cmFunc.h</b> defines the Cortex-M Core Register access functions (defined as <strong>static inline</strong>).
</p>
<p>
  File <b>core_cmInstr.h</b> defines the Cortex-M Core instructions (defined as <strong>static inline</strong>).
</p>
<p>These files are part of the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M.</p>

<h3>startup_<em>device</em></h3>
<p>
  A template file for <strong>startup_<em>device</em></strong> is provided by ARM for each supported
  compiler. It is adapted by the silicon vendor to include interrupt vectors for all device specific 
  interrupt handlers. Each interrupt handler is defined as <strong><em>weak</em></strong> function 
  to an dummy handler. Therefore the interrupt handler can be directly used in application software 
  without any requirements to adapt the <strong>startup_<em>device</em></strong> file.
</p>
<p>
  The following exception names are fixed and define the start of the vector table for a Cortex-M0:
</p>
<pre>
__Vectors       DCD     __initial_sp              ; Top of Stack
                DCD     Reset_Handler             ; Reset Handler
                DCD     NMI_Handler               ; NMI Handler
                DCD     HardFault_Handler         ; Hard Fault Handler
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     SVC_Handler               ; SVCall Handler
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     PendSV_Handler            ; PendSV Handler
                DCD     SysTick_Handler           ; SysTick Handler</pre>

<p>
  The following exception names are fixed and define the start of the vector table for a Cortex-M3:
</p>
<pre>
__Vectors       DCD     __initial_sp              ; Top of Stack
                DCD     Reset_Handler             ; Reset Handler
                DCD     NMI_Handler               ; NMI Handler
                DCD     HardFault_Handler         ; Hard Fault Handler
                DCD     MemManage_Handler         ; MPU Fault Handler
                DCD     BusFault_Handler          ; Bus Fault Handler
                DCD     UsageFault_Handler        ; Usage Fault Handler
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     0                         ; Reserved
                DCD     SVC_Handler               ; SVCall Handler
                DCD     DebugMon_Handler          ; Debug Monitor Handler
                DCD     0                         ; Reserved
                DCD     PendSV_Handler            ; PendSV Handler
                DCD     SysTick_Handler           ; SysTick Handler</pre>

<p>
  In the following examples for device specific interrupts are shown:
</p>
<pre>
; External Interrupts
                DCD     WWDG_IRQHandler           ; Window Watchdog
                DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
                DCD     TAMPER_IRQHandler         ; Tamper</pre>

<p>
  Device specific interrupts must have a dummy function that can be overwritten in user code. 
  Below is an example for this dummy function.
</p>
<pre>
Default_Handler PROC
                EXPORT WWDG_IRQHandler   [WEAK]
                EXPORT PVD_IRQHandler    [WEAK]
                EXPORT TAMPER_IRQHandler [WEAK]
                :
                :
                WWDG_IRQHandler
                PVD_IRQHandler
                TAMPER_IRQHandler
                :
                :
                B .
                ENDP</pre>
                
<p>
  The user application may simply define an interrupt handler function by using the handler name
  as shown below.
</p>
<pre>
void WWDG_IRQHandler(void)
{
  :
  :
}</pre>


<h3><a name="4"></a>system_<em>device</em>.c</h3>
<p>
  A template file for <strong>system_<em>device</em>.c</strong> is provided by ARM but adapted by 
  the silicon vendor to match their actual device. As a <strong>minimum requirement</strong> 
  this file must provide a device specific system configuration function and a global variable 
  that contains the system frequency. It configures the device and initializes typically the 
  oscillator (PLL) that is part of the microcontroller device.
</p>
<p>
  The file <strong>system_</strong><em><strong>device</strong></em><strong>.c</strong> must provide
  as a minimum requirement the SystemInit function as shown below.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt">Function Definition</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void SystemInit (void)</td>
      <td class="kt">Setup the microcontroller system. Typically this function configures the 
                     oscillator (PLL) that is part of the microcontroller device. For systems 
                     with variable clock speed it also updates the variable SystemCoreClock.<br>
                     SystemInit is called from startup<i>_device</i> file.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void SystemCoreClockUpdate (void)</td>
      <td class="kt">Updates the variable SystemCoreClock and must be called whenever the 
                     core clock is changed during program execution. SystemCoreClockUpdate()
                     evaluates the clock register settings and calculates the current core clock.
</td>
    </tr>
  </tbody>
</table>

<p>
  Also part of the file <strong>system_</strong><em><strong>device</strong></em><strong>.c</strong> 
  is the variable <strong>SystemCoreClock</strong> which contains the current CPU clock speed shown below.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt">Variable Definition</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t SystemCoreClock</td>
      <td class="kt">Contains the system core clock (which is the system clock	frequency supplied 
                     to the SysTick timer and the processor core clock). This variable can be 
                     used by the user application to setup the SysTick timer or configure other 
                     parameters. It may also be used by debugger to query the frequency of the 
                     debug timer or configure the trace clock speed.<br>
                     SystemCoreClock is initialized with a correct predefined value.<br><br>
		                 The compiler must be configured to avoid the removal of this variable in 
		                 case that the application program is not using it. It is important for 
		                 debug systems that the variable is physically present in memory so that 
		                 it can be examined to configure the debugger.</td>
    </tr>
  </tbody>
</table>

<p class="Note">Note</p>
<ul>
  <li><p>The above definitions are the minimum requirements for the file <strong>
	system_</strong><em><strong>device</strong></em><strong>.c</strong>. This 
	file may export more functions or variables that provide a more flexible 
	configuration of the microcontroller system.</p>
  </li>
</ul>


<h2>Core Peripheral Access Layer</h2>

<h3>Cortex-M Core Register Access</h3>
<p>
  The following functions are defined in <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong>
  and provide access to Cortex-M core registers.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt">Function Definition</th>
      <th class="kt">Core</th>
      <th class="kt">Core Register</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __enable_irq (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">PRIMASK = 0</td>
      <td class="kt">Global Interrupt enable (using the instruction <strong>CPSIE	i</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __disable_irq (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">PRIMASK = 1</td>
      <td class="kt">Global Interrupt disable (using the instruction <strong>CPSID i</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_CONTROL (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return CONTROL</td>
      <td class="kt">Return Control Register Value (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_CONTROL (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">CONTROL = value</td>
      <td class="kt">Set CONTROL register value (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_IPSR (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return IPSR</td>
      <td class="kt">Return IPSR Register Value (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_APSR (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return APSR</td>
      <td class="kt">Return APSR Register Value (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_xPSR (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return xPSR</td>
      <td class="kt">Return xPSR Register Value (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_PSP (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return PSP</td>
      <td class="kt">Return Process Stack Pointer (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_PSP (uint32_t TopOfProcStack)</td>
      <td class="kt" nowrap="nowrap">>M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">PSP = TopOfProcStack</td>
      <td class="kt">Set Process Stack Pointer value (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_MSP (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return MSP</td>
      <td class="kt">Return Main Stack Pointer (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_MSP (uint32_t TopOfMainStack)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">MSP = TopOfMainStack</td>
      <td class="kt">Set Main Stack Pointer (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_PRIMASK (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">return PRIMASK</td>
      <td class="kt">Return Priority Mask Register (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_PRIMASK (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">PRIMASK = value</td>
      <td class="kt">Assign value to Priority Mask Register (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __enable_fault_irq (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">FAULTMASK = 0</td>
      <td class="kt">Global Fault exception and Interrupt enable (using the instruction <strong>CPSIE f</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __disable_fault_irq (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">FAULTMASK = 1</td>
      <td class="kt">Global Fault exception and Interrupt disable (using the instruction <strong>CPSID f</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_BASEPRI (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">return BASEPRI</td>
      <td class="kt">Return Base Priority (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_BASEPRI (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">BASEPRI = value</td>
      <td class="kt">Set Base Priority (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_FAULTMASK (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">return FAULTMASK</td>
      <td class="kt">Return Fault Mask Register (using the instruction <strong>MRS</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_FAULTMASK (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">FAULTMASK = value</td>
      <td class="kt">Assign value to Fault Mask Register (using the instruction <strong>MSR</strong>)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __get_FPSCR (void)</td>
      <td class="kt" nowrap="nowrap">M4</td>
      <td class="kt" nowrap="nowrap">return FPSCR</td>
      <td class="kt">Return Floating Point Status / Control Register</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __set_FPSCR (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M4</td>
      <td class="kt" nowrap="nowrap">FPSCR = value</td>
      <td class="kt">Assign value to Floating Point Status / Control Register</td>
    </tr>
  </tbody>
</table>

<h3>Cortex-M Instruction Access</h3>
<p>
  The following functions are defined in <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong>and
  generate specific Cortex-M instructions. The functions are implemented in the file 
  <strong>core_cm0.c</strong> / <strong>core_cm3.c</strong>.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt">Name</th>
      <th class="kt">Core</th>
      <th class="kt">Generated CPU Instruction</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __NOP (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">NOP</td>
      <td class="kt">No Operation</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __WFI (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">WFI</td>
      <td class="kt">Wait for Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __WFE (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">WFE</td>
      <td class="kt">Wait for Event</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __SEV (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">SEV</td>
      <td class="kt">Set Event</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __ISB (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">ISB</td>
      <td class="kt">Instruction Synchronization Barrier</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __DSB (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">DSB</td>
      <td class="kt">Data Synchronization Barrier</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void __DMB (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">DMB</td>
      <td class="kt">Data Memory Barrier</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __REV (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">REV</td>
      <td class="kt">Reverse byte order in integer value.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __REV16 (uint16_t value)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">REV16</td>
      <td class="kt">Reverse byte order in unsigned short value. </td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">sint32_t __REVSH (sint16_t value)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">REVSH</td>
      <td class="kt">Reverse byte order in signed short value with sign extension to integer.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __RBIT (uint32_t value)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">RBIT</td>
      <td class="kt">Reverse bit order of value</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint8_t __LDREXB (uint8_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">LDREXB</td>
      <td class="kt">Load exclusive byte</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint16_t __LDREXH (uint16_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">LDREXH</td>
      <td class="kt">Load exclusive half-word</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __LDREXW (uint32_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">LDREXW</td>
      <td class="kt">Load exclusive word</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint8_t __STREXB (uint8_t value, uint8_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">STREXB</td>
      <td class="kt">Store exclusive byte</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint16_t __STREXH (uint16_t value, uint16_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">STREXH</td>
      <td class="kt">Store exclusive half-word</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t __STREXW (uint32_t value, uint32_t *addr)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">STREXW</td>
      <td class="kt">Store exclusive word</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void  __CLREX (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">CLREX</td>
      <td class="kt">Remove the exclusive lock created by __LDREXB, __LDREXH, or __LDREXW</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void  __SSAT (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">SSAT</td>
      <td class="kt">saturate a signed value</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void  __USAT (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">USAT</td>
      <td class="kt">saturate an unsigned value</td>
    </tr>
  </tbody>
</table>


<h3>NVIC Access Functions</h3>
<p>
  The CMSIS provides access to the NVIC via the register interface structure and several helper
  functions that simplify the setup of the NVIC. The CMSIS HAL uses IRQ numbers (IRQn) to 
  identify the interrupts. The first device interrupt has the IRQn value 0. Therefore negative 
  IRQn values are used for processor core exceptions.
</p>
<p>
  For the IRQn values of core exceptions the file <strong><em>device.h</em></strong> provides 
  the following enum names.
</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">Core Exception enum Value</th>
      <th class="kt">Core</th>
      <th class="kt">IRQn</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">NonMaskableInt_IRQn</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">-14</td>
      <td class="kt">Cortex-M Non Maskable Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">HardFault_IRQn</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">-13</td>
      <td class="kt">Cortex-M Hard Fault Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">MemoryManagement_IRQn</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">-12</td>
      <td class="kt">Cortex-M Memory Management Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">BusFault_IRQn</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">-11</td>
      <td class="kt">Cortex-M Bus Fault Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">UsageFault_IRQn</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">-10</td>
      <td class="kt">Cortex-M Usage Fault Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">SVCall_IRQn</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">-5</td>
      <td class="kt">Cortex-M SV Call Interrupt </td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">DebugMonitor_IRQn</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">-4</td>
      <td class="kt">Cortex-M Debug Monitor Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">PendSV_IRQn</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">-2</td>
      <td class="kt">Cortex-M Pend SV Interrupt</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">SysTick_IRQn</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">-1</td>
      <td class="kt">Cortex-M System Tick Interrupt</td>
    </tr>
  </tbody>
</table>

<p>The following functions simplify the setup of the NVIC.
The functions are defined as <strong>static inline</strong>.</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">Name</th>
      <th class="kt">Core</th>
      <th class="kt">Parameter</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_SetPriorityGrouping (uint32_t PriorityGroup)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">Priority Grouping Value</td>
      <td class="kt">Set the Priority Grouping (Groups . Subgroups)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPriorityGrouping (void)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">(void)</td>
      <td class="kt">Get the Priority Grouping (Groups . Subgroups)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_EnableIRQ (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Enable IRQn</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_DisableIRQ (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Disable IRQn</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPendingIRQ (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Return 1 if IRQn is pending else 0</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_SetPendingIRQ (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Set IRQn Pending</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_ClearPendingIRQ (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Clear IRQn Pending Status</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetActive (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Return 1 if IRQn is active else 0</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_SetPriority (<br>
	  &nbsp;&nbsp;IRQn_Type IRQn,<br>
	  &nbsp;&nbsp;uint32_t priority)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number, Priority</td>
      <td class="kt">Set Priority for IRQn<br>
                     (not threadsafe for Cortex-M0)</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPriority (IRQn_Type IRQn)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number</td>
      <td class="kt">Get Priority for IRQn</td>
    </tr>
    <tr>
<!--      <td class="kt" nowrap="nowrap">uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)</td> -->
      <td class="kt" nowrap="nowrap">uint32_t NVIC_EncodePriority (<br>
	  &nbsp;&nbsp;uint32_t PriorityGroup,<br>
	  &nbsp;&nbsp;uint32_t PreemptPriority,<br>
	  &nbsp;&nbsp;uint32_t SubPriority)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap">IRQ Number,<br>
	  Priority Group,<br>
	  Preemptive Priority,<br>
	  Sub Priority</td>
      <td class="kt">Encode priority for given group, preemptive and sub priority</td>
    </tr>
<!--      <td class="kt" nowrap="nowrap">NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)</td> -->
      <td class="kt" nowrap="nowrap">void NVIC_DecodePriority (<br>
	  &nbsp;&nbsp;uint32_t Priority,<br> 
	  &nbsp;&nbsp;uint32_t PriorityGroup,<br> 
	  &nbsp;&nbsp;uint32_t* pPreemptPriority,<br> 
	  &nbsp;&nbsp;uint32_t* pSubPriority)</td>
      <td class="kt" nowrap="nowrap">M3, M4</td>
      <td class="kt" nowrap="nowrap"><br>
	  Priority,<br>
	  Priority Group,<br>
	  pointer to Preempt. Priority,<br>
	  pointer to Sub Priority</td>
      <td class="kt">Decode given priority to group, preemptive and sub priority</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void NVIC_SystemReset (void)</td>
      <td class="kt" nowrap="nowrap">M0, M3, M4</td>
      <td class="kt" nowrap="nowrap">(void)</td>
      <td class="kt">Resets the System</td>
    </tr>
  </tbody>
</table>
<p class="Note">Note</p>
<ul>
  <li><p>The processor exceptions have negative enum values. Device specific interrupts 
         have positive enum values and start with 0. The values are defined in
         <b><em>device.h</em></b> file.
      </p>
  </li>
  <li><p>The values for <b>PreemptPriority</b> and <b>SubPriority</b>
         used in functions <b>NVIC_EncodePriority</b> and <b>NVIC_DecodePriority</b>
         depend on the available __NVIC_PRIO_BITS implemented in the NVIC.
      </p>
  </li>
</ul>


<h3>SysTick Configuration Function</h3>

<p>The following function is used to configure the SysTick timer and start the 
SysTick interrupt.</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">Name</th>
      <th class="kt">Parameter</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">uint32_t Sys<span class="style1">TickConfig (uint32_t ticks)</span></td>
      <td class="kt">ticks is SysTick counter reload value</td>
      <td class="kt">Setup the SysTick timer and enable the SysTick interrupt. After this 
        call the SysTick timer creates interrupts with the specified time interval.<br><br>
        Return: 0 when successful, 1 on failure.<br>
      </td>
    </tr>
  </tbody>
</table>


<h3>Cortex-M3 / Cortex-M4 ITM Debug Access</h3>

<p>The Cortex-M3 / Cortex-M4 incorporates the Instrumented Trace Macrocell (ITM) that 
provides together with the Serial Viewer Output trace capabilities for the 
microcontroller system. The ITM has 32 communication channels; two ITM 
communication channels are used by CMSIS to output the following information:</p>
<ul>
  <li>ITM Channel 0: implements the <strong>ITM_SendChar</strong> function 
      which can be used for printf-style output via the debug interface.</li>
  <li>ITM Channel 31: is reserved for the RTOS kernel and can be used for 
      kernel awareness debugging.</li>
</ul>
<p class="Note">Note</p>
<ul>
  <li><p>The ITM channel 31 is selected for the RTOS kernel since some kernels 
      may use the Privileged level for program execution. ITM 
      channels have 4 groups with 8 channels each, whereby each group can be 
      configured for access rights in the Unprivileged level. The ITM channel 0 
      may be therefore enabled for the user task whereas ITM channel 31 may be 
      accessible only in Privileged level from the RTOS kernel itself.</p>
  </li>
</ul>

<p>The prototype of the <strong>ITM_SendChar</strong> routine is shown in the 
table below.</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">Name</th>
      <th class="kt">Parameter</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">void uint32_t ITM_SendChar(uint32_t chr)</td>
      <td class="kt">character to output</td>
      <td class="kt">The function outputs a character via the ITM channel 0. The 
                     function returns when no debugger is connected that has booked the 
                     output. It is blocking when a debugger is connected, but the 
                     previous character send is not transmitted.<br><br>
                     Return: the input character 'chr'.
      </td>
    </tr>
  </tbody>
</table>

<p>
  Example for the usage of the ITM Channel 31 for RTOS Kernels:
</p>
<pre>
  // check if debugger connected and ITM channel enabled for tracing
  if ((CoreDebug-&gt;DEMCR &amp; CoreDebug_DEMCR_TRCENA) &amp;&amp;
  (ITM-&gt;TCR &amp; ITM_TCR_ITMENA) &amp;&amp;
  (ITM-&gt;TER &amp; (1UL &lt;&lt; 31))) {
    // transmit trace data
    while (ITM-&gt;PORT31_U32 == 0);
    ITM-&gt;PORT[31].u8 = task_id;      // id of next task
    while (ITM-&gt;PORT[31].u32 == 0);
    ITM-&gt;PORT[31].u32 = task_status; // status information
  }</pre>


<h3>Cortex-M3 additional Debug Access</h3>

<p>CMSIS provides additional debug functions to enlarge the Cortex-M3 Debug Access.
Data can be transmitted via a certain global buffer variable towards the target system.</p>

<p>The buffer variable and the prototypes of the additional functions are shown in the 
table below.</p>

<table class="kt" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <th class="kt" nowrap="nowrap">Name</th>
      <th class="kt">Parameter</th>
      <th class="kt">Description</th>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">extern volatile int ITM_RxBuffer</td>
      <td class="kt"> </td>
      <td class="kt">Buffer to transmit data towards debug system. <br><br>
                     Value 0x5AA55AA5 indicates that buffer is empty.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">int ITM_ReceiveChar (void)</td>
      <td class="kt">none</td>
      <td class="kt">The nonblocking functions returns the character stored in 
                     ITM_RxBuffer. <br><br>
                     Return: -1 indicates that no character was received.</td>
    </tr>
    <tr>
      <td class="kt" nowrap="nowrap">int ITM_CheckChar (void)</td>
      <td class="kt">none</td>
      <td class="kt">The function checks if a character is available in ITM_RxBuffer. <br><br>
                     Return: 1 indicates that a character is available, 0 indicates that
                     no character is available.</td>
    </tr>
  </tbody>
</table>


<h2><a name="5"></a>CMSIS Example</h2>
<p>
  The following section shows a typical example for using the CMSIS layer in user applications.
  The example is based on a STM32F10x Device.
</p>
<pre>
#include "stm32f10x.h"

volatile uint32_t msTicks;                       /* timeTicks counter */

void SysTick_Handler(void) {
  msTicks++;                                     /* increment timeTicks counter */
}

__INLINE static void Delay (uint32_t dlyTicks) {
  uint32_t curTicks = msTicks;

  while ((msTicks - curTicks) &lt; dlyTicks);
}

__INLINE static void LED_Config(void) {
  ;                                              /* Configure the LEDs */
}

__INLINE static void LED_On (uint32_t led) {
  ;                                              /* Turn On  LED */
}

__INLINE static void LED_Off (uint32_t led) {
  ;                                              /* Turn Off LED */
}

int main (void) {
  if (SysTick_Config (SystemCoreClock / 1000)) { /* Setup SysTick for 1 msec interrupts */
    ;                                            /* Handle Error */
    while (1);
  }
  
  LED_Config();                                  /* configure the LEDs */                            
 
  while(1) {
    LED_On (0x100);                              /* Turn  on the LED   */
    Delay (100);                                 /* delay  100 Msec    */
    LED_Off (0x100);                             /* Turn off the LED   */
    Delay (100);                                 /* delay  100 Msec    */
  }
}</pre>


<h2><a name="6"></a>CMSIS MISRA-C:2004 Compliance Exceptions</h2>
<p>
  CMSIS violates following MISRA-C2004 Rules:
</p>
<ul>
   <li>Violates MISRA 2004 Required Rule 8.5, object/function definition in header file.<br>
       Function definitions in header files are used to allow 'inlining'.</li> 

   <li>Violates MISRA 2004 Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
       Unions are used for effective representation of core registers.</li>
   
   <li>Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.<br>
       Function-like macros are used to allow more efficient code.</li> 
</ul>

<p>&nbsp;&nbsp;</p>

</body></html>